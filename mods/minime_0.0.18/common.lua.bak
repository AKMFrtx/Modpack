return function (mod_name)
log("Entered common.lua!")

  local common = {}



  ------------------------------------------------------------------------------------
  -- Get mod name and path to mod
  common.modName = mod_name
  common.modRoot = "__" .. mod_name .. "__"

  ------------------------------------------------------------------------------------
  -- When looking for alternative characters, use this search pattern
  common.pattern = "SKIN"

  ------------------------------------------------------------------------------------
  -- Name of the surface we create as storage for dummy characters
  common.dummy_surface = "dummy_dungeon"

  ------------------------------------------------------------------------------------
  -- Name of the dummy character prototype
  common.dummy_character_name = "minime_character_dummy"

  ------------------------------------------------------------------------------------
  -- Name of God-mode button
  common.remove_character_name = "God-mode"

  ------------------------------------------------------------------------------------
  -- Names of inventories
  common.inventory_list = { "ammo", "armor", "guns", "main", "trash" }

  ------------------------------------------------------------------------------------
  -- Number of dummy's bonus trash slots
  common.character_trash_slot_count_bonus = 500


  ------------------------------------------------------------------------------------
  -- Enable character selector?
  common.minime_character_selector = settings.startup["minime_character-selector"].value

  ------------------------------------------------------------------------------------
  -- Close GUI after a character has been selected?
  common.minime_close_gui_on_selection = settings.startup["minime_close-gui-on-selection"].value

  ------------------------------------------------------------------------------------
  -- Look for matching pattern at start of a string
  common.prefixed = function(str, start)
    return str:sub(1, #start) == start
  end


  ------------------------------------------------------------------------------------
  -- Enable writing to log file until startup options are set, so debugging output
  -- from the start of a game session can be logged. This depends on a locally
  -- installed dummy mod to allow debugging output during development without
  -- spamming real users.
  -- If you don't have this mod or don't want to activate it, you can also change
  -- the value of debug_default!
  local debug_default = false
  -- Control stage
  if game then
    common.debug_in_log = (game.active_mods["_debug"] and true) or debug_default
  -- on_load
  elseif script then
    common.debug_in_log = (script.active_mods["_debug"] and true) or debug_default
  -- Data stage
  else
    common.debug_in_log = (mods["_debug"] and true) or debug_default
  end


  ------------------------------------------------------------------------------------
  -- Output: Print to user and debug-print
  common.output = function(player, msg)
      --~ common.dprint("Entered function " .. common.modName .. ".output(" ..
                    --~ tostring(player.name) .. ", " .. tostring({msg}) .. ")")

    if player.valid and player.is_player() then
      player.print({"", msg})
      --~ common.dprint({"", msg})
    elseif not player.valid then
      common.dprint({"", common.modName, ": Couldn't print to player -- player isn't valid!"})
    else
      common.dprint({"", common.modName, ": Couldn't print to " .. player.name .. " -- not a player!"})
    end

    --~ common.dprint("End of function " .. common.modName .. ".output(" ..
                    --~ tostring(player.name) .. ", " .. tostring({msg}) .. ")")
  end

  ------------------------------------------------------------------------------------
  -- Debug function
  common.dprint = function(msg)
      --~ log("Entered function " .. common.modName .. ".dprint(" .. tostring({msg}) .. ")")

    if common.debug_in_log then log({"", msg}) end

    if game and msg then
      for _,player in pairs(game.players) do
        local index = player.index
        if global.player_settings and global.player_settings[index]
                                  and global.player_settings[index].debug_in_game then
          --~ game.players[index].print({"", common.modName, ': ', msg}, {r=.75, g=.5, b=.25})
          game.players[index].print({"", common.modName, ': ', msg})
        end
      end
    end
    --~ log("End of function " .. common.modName .. ".dprint(" .. tostring({msg}) .. ")")
  end

  ------------------------------------------------------------------------------------
  -- Helper function to show value and type of variables
  common.show = function(var, msg)
      common.dprint({"", "Show", tostring(msg and " " .. msg), ":\t" .. serpent.block(var)})
  end


  ------------------------------------------------------------------------------------
  -- Localize entity names for output routines
  -- (Returns localized entity name; falls back to entity name, or to default string)
  common.loc_name = function (entity)
      --~ return entity and entity.valid and entity.localised_name or {"", entity.name}
      return entity and entity.valid and (entity.localised_name or entity.name) or ""
  end

  ------------------------------------------------------------------------------------
  -- Create a dummy character
  common.make_dummy = function(p)
    local f_name = "make_dummy"
    common.dprint("Entered function " .. f_name .. "(" .. serpent.line(p) .. ").")

    p = p and (type(p) == "number") and game.players[p] or p
    if not (p and p.valid and p.is_player()) then
      error(serpent.line(p) .. " is not a valid player!")
    end

    local dummy = game.surfaces[common.dummy_surface].create_entity{
      --~ name = "character",
      name = common.dummy_character_name,
      position = {0, 0}
    }
    common.dprint("Created dummy character for player " .. p.name .. ".")

    -- Add a generous amount of trash slots
    dummy.character_trash_slot_count_bonus = common.character_trash_slot_count_bonus

    -- Check if we have an old dummy that we need to migrate
    local p_data = global.player_data[p.index]
    if p_data and p_data.dummy and (p_data.dummy.name ~= common.dummy_character_name) then
log("Trying to call copy_character from common.lua!")
      copy_character(global.player_data[p].dummy, dummy)
    end

    common.dprint("End of function " .. f_name .. "(" .. serpent.line(p) .. ").")
    return dummy
  end


  ------------------------------------------------------------------------------------
  --                               Transfer inventory!                              --
  ------------------------------------------------------------------------------------
  common.transfer_inventory = function(src, dst)
    local f_name = "transfer_inventory"
    common.dprint("Entered function " .. f_name .. "(" .. tostring(src) .. ", " .. tostring(dst) .. ")")

    for _, i in ipairs({ src, dst }) do
      if not (i and i.valid) then
        error(serpent.line(i) .. " is not a valid inventory!")
      end
    end

    common.dprint("SRC slots: " .. #src)
    common.dprint("DST slots: " .. #dst)

    local limit = (#src > #dst) and #dst or #src

    -- Transfer inventory contents if inventory isn't empty
    if src.is_empty() then
      -- Shouldn't be really necessary, but just let's play it safe!
      dst.clear()
    else
      for i = 1, limit do
        local test_d = dst[i].valid_for_read
        local test_s = src[i].valid_for_read
        common.dprint("src[" .. i .. "]: " .. serpent.line(test_s and src[i].name) .. " (" .. serpent.line(test_s and src[i].count) .. ")\tdst[" .. i .. "]:" .. serpent.line(test_d and dst[i].name) .. " (" .. serpent.line(test_d and dst[i].count) .. ")")
        --~ dst[i].transfer_stack(src[i])         -- Doesn't work, it moves items.
        dst[i].set_stack(src[i])                  -- Much better, this copies them!

        test_d = dst[i].valid_for_read
        common.dprint("dst[" .. i .. "]: " .. serpent.line(test_d and dst[i].name) .. " (" .. serpent.line(test_d and dst[i].count) .. ")")
      end
      common.dprint("Transferred " .. limit .. tostring(limit == 1 and " stack." or " stacks."))
    end

    -- Copy filters if at least one slot is filtered
    if src.is_filtered() then
      for i = 1, limit do
        dst.set_filter(i, src.get_filter(i))
      end
      common.dprint("Set filters")
    end

    common.dprint("End of function " .. f_name .. "(" .. tostring(src) .. ", " .. tostring(dst) .. ")")
  end


  log("End of common.lua!")
  return common

end
